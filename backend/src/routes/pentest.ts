import express from 'express';
import { pool } from '../db';
import { authenticate, requireOrganization, AuthRequest } from '../middleware/auth';
import { generatePlainEnglishExplanation, generateRemediationSteps } from '../services/ai/openai';

const router = express.Router();

router.use(authenticate);
router.use(requireOrganization);

// List pentest sessions
router.get('/sessions', async (req: AuthRequest, res) => {
  try {
    const result = await pool.query(
      `SELECT s.*, u.name as user_name
       FROM pentest_sessions s
       LEFT JOIN users u ON s.user_id = u.id
       WHERE s.organization_id = $1
       ORDER BY s.created_at DESC`,
      [req.organizationId]
    );

    res.json({ sessions: result.rows });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

// Create pentest session
router.post('/sessions', async (req: AuthRequest, res) => {
  try {
    const { target_url, config } = req.body;

    if (!target_url) {
      return res.status(400).json({ error: 'Target URL required' });
    }

    const result = await pool.query(
      `INSERT INTO pentest_sessions (organization_id, user_id, target_url, config, status)
       VALUES ($1, $2, $3, $4, 'active')
       RETURNING *`,
      [req.organizationId, req.user!.id, target_url, JSON.stringify(config || {})]
    );

    res.json({ session: result.rows[0] });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

// Get session details
router.get('/sessions/:sessionId', async (req: AuthRequest, res) => {
  try {
    const { sessionId } = req.params;

    const result = await pool.query(
      `SELECT s.*, u.name as user_name
       FROM pentest_sessions s
       LEFT JOIN users u ON s.user_id = u.id
       WHERE s.id = $1 AND s.organization_id = $2`,
      [sessionId, req.organizationId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Session not found' });
    }

    res.json({ session: result.rows[0] });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

// Get findings for session
router.get('/sessions/:sessionId/findings', async (req: AuthRequest, res) => {
  try {
    const { sessionId } = req.params;

    // Verify session belongs to organization
    const sessionResult = await pool.query(
      'SELECT id FROM pentest_sessions WHERE id = $1 AND organization_id = $2',
      [sessionId, req.organizationId]
    );

    if (sessionResult.rows.length === 0) {
      return res.status(404).json({ error: 'Session not found' });
    }

    const findingsResult = await pool.query(
      'SELECT * FROM pentest_findings WHERE pentest_session_id = $1 ORDER BY created_at DESC',
      [sessionId]
    );

    res.json({ findings: findingsResult.rows });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

// Create finding (from AI analysis or manual)
router.post('/sessions/:sessionId/findings', async (req: AuthRequest, res) => {
  try {
    const { sessionId } = req.params;
    const { vulnerability_type, severity, technical_details, raw_data } = req.body;

    if (!vulnerability_type || !severity) {
      return res.status(400).json({ error: 'Vulnerability type and severity required' });
    }

    // Verify session
    const sessionResult = await pool.query(
      'SELECT * FROM pentest_sessions WHERE id = $1 AND organization_id = $2',
      [sessionId, req.organizationId]
    );

    if (sessionResult.rows.length === 0) {
      return res.status(404).json({ error: 'Session not found' });
    }

    // Generate AI explanations
    const aiExplanation = await generatePlainEnglishExplanation({
      findingType: vulnerability_type,
      severity,
      technicalDetails: technical_details || raw_data || {},
    });

    const remediationSteps = await generateRemediationSteps(
      vulnerability_type,
      technical_details || raw_data || {}
    );

    // Create executive summary
    const executiveSummary = `This ${vulnerability_type} vulnerability (${severity} severity) could allow attackers to ${getImpactDescription(vulnerability_type)}. Immediate remediation is recommended.`;

    const result = await pool.query(
      `INSERT INTO pentest_findings
       (pentest_session_id, vulnerability_type, severity, title, description,
        technical_details, executive_summary, remediation_steps, raw_data, status)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, 'open')
       RETURNING *`,
      [
        sessionId,
        vulnerability_type,
        severity,
        `${vulnerability_type.replace(/_/g, ' ')} vulnerability`,
        aiExplanation,
        JSON.stringify(technical_details || {}),
        executiveSummary,
        JSON.stringify(remediationSteps),
        JSON.stringify(raw_data || {}),
      ]
    );

    res.json({ finding: result.rows[0] });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

// Update finding status
router.patch('/findings/:findingId', async (req: AuthRequest, res) => {
  try {
    const { findingId } = req.params;
    const { status } = req.body;

    if (!status) {
      return res.status(400).json({ error: 'Status required' });
    }

    // Verify finding belongs to organization
    const findingResult = await pool.query(
      `SELECT f.* FROM pentest_findings f
       JOIN pentest_sessions s ON f.pentest_session_id = s.id
       WHERE f.id = $1 AND s.organization_id = $2`,
      [findingId, req.organizationId]
    );

    if (findingResult.rows.length === 0) {
      return res.status(404).json({ error: 'Finding not found' });
    }

    const result = await pool.query(
      `UPDATE pentest_findings
       SET status = $1, updated_at = NOW()
       WHERE id = $2
       RETURNING *`,
      [status, findingId]
    );

    res.json({ finding: result.rows[0] });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

function getImpactDescription(vulnType: string): string {
  const impacts: Record<string, string> = {
    sql_injection: 'access or manipulate database records',
    xss: 'steal user sessions or deface the application',
    csrf: 'perform unauthorized actions on behalf of users',
    authentication_bypass: 'gain unauthorized access to the system',
    privilege_escalation: 'gain elevated permissions',
    information_disclosure: 'access sensitive information',
  };
  return impacts[vulnType] || 'compromise the application';
}

export default router;

